<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Homework 6 ‚Äî Online Mean & Variance | Cybersecurity Statistics Blog</title>

  <!-- MathJax for formulas -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* Keep the same clean look as HW5 */
    :root{--maxw:900px; --accent:#0b4cc2; --muted:#6b7280;}
    body{font-family: "Segoe UI", Roboto, Arial, sans-serif; background:#fafafa; color:#111; margin:0; padding:0;}
    header{background:#0f172a; color:#fff; padding:2.2rem 1rem; text-align:center}
    header h1{margin:.1rem 0; font-size:1.4rem}
    header p{margin:.2rem 0 .2rem; color:#cbd5e1}
    main{max-width:var(--maxw); margin:1.5rem auto; padding:1.2rem; box-sizing:border-box}
    .card{background:#fff; border-radius:10px; padding:1.6rem; box-shadow:0 6px 18px rgba(12,15,20,0.06)}
    h2{color:var(--accent); margin-top:0}
    h3{color:#0b3b3b}
    p{line-height:1.6; margin:.6rem 0}
    pre, code{background:#f3f4f6; padding:10px; border-radius:8px; overflow:auto; font-family:monospace}
    table{width:100%; border-collapse:collapse; margin-top:.6rem}
    th,td{padding:.6rem; border:1px solid #e6eef0; text-align:left}
    th{background:#f1f8ff}
    nav.links{display:flex; gap:.6rem; margin-top:1rem}
    nav.links a{background:#f8fafc; padding:.45rem .7rem; border-radius:8px; text-decoration:none; color:#0f172a; border:1px solid #e2e8f0}
    .muted{color:var(--muted)}
    footer{margin-top:12px; text-align:center; color:var(--muted); padding:1rem 0}
    .small{font-size:.95rem}
    .result-table{margin-top:1rem}
    .kbd{background:#eef2f2; padding:.12rem .4rem; border-radius:6px}
  </style>
</head>
<body>
  <header>
    <h1>Cybersecurity Statistics Blog</h1>
    <p>Homework 6 ‚Äî Recurrence proofs and online computation of mean & variance</p>
  </header>

  <main>
    <article class="card">
      <h2>What this homework contains</h2>
      <p class="small muted">Derivations of one-pass recurrences for mean and variance (Welford), a JavaScript implementation, a step-by-step numeric verification, and a short discussion on numerical stability and complexity.</p>

      <h3>Introduction (one paragraph)</h3>
      <p>
        Batch formulas recompute statistics over the full dataset and require storing all observations. For streaming or very large datasets this is impractical and can also be numerically fragile. Online (incremental) formulas update quantities using only the current count, a running mean and a running sum of squared deviations. They run in constant time per update and avoid catastrophic cancellation if implemented carefully.
      </p>

      <h3>I. Recurrence ‚Äî mean (short proof)</h3>
      <p>
        Let the data be \(x_1,\dots,x_n\) and the mean after \(n\) points be \(\bar{x}_n\):
      </p>
      <p style="text-align:center;">\[
        \bar{x}_n = \frac{1}{n}\sum_{i=1}^n x_i
      \]</p>
      <p>
        After adding \(x_{n+1}\):
      </p>
      <p style="text-align:center;">\[
        \bar{x}_{n+1} = \frac{1}{n+1}\Big(\sum_{i=1}^n x_i + x_{n+1}\Big)
        = \frac{n\bar{x}_n + x_{n+1}}{n+1}
        = \bar{x}_n + \frac{x_{n+1}-\bar{x}_n}{n+1}.
      \]</p>
      <p class="small muted">That last form is the convenient incremental update used in practice.</p>

      <h3>II. Recurrence ‚Äî variance (Welford; short proof)</h3>
      <p>
        Define \(M_{2,n}=\sum_{i=1}^n (x_i-\bar{x}_n)^2\). The sample variance is \(s_n^2 = M_{2,n}/(n-1)\) for \(n\ge 2\).
        Welford's recurrence updates \(M_2\) without computing the whole sum again.
      </p>

      <p style="text-align:center;">
        Let \(\delta = x_{n+1}-\bar{x}_n,\quad \bar{x}_{n+1}=\bar{x}_n + \delta/(n+1).\)
      </p>

      <p style="text-align:center;">
        \[
          M_{2,n+1} = M_{2,n} + \delta\,(x_{n+1}-\bar{x}_{n+1}).
        \]
      </p>

      <p class="small muted">Proof sketch: substitute \(x_i-\bar{x}_{n+1} = (x_i-\bar{x}_n) + (\bar{x}_n-\bar{x}_{n+1})\) in the definition of \(M_{2,n+1}\), expand squares and observe cancellation of cross-terms; the algebra simplifies to the formula above.</p>

      <h3>III. JavaScript implementation (Welford)</h3>
      <p class="small muted">This class performs online updates and exposes mean, population variance and sample variance.</p>

      <pre><code>// Online Welford implementation (JavaScript)
class OnlineStats {
  constructor() {
    this.n = 0;
    this.mean = 0;
    this.M2 = 0;
  }

  // add a new sample x
  add(x) {
    this.n += 1;
    const delta = x - this.mean;
    this.mean += delta / this.n;
    const delta2 = x - this.mean;
    this.M2 += delta * delta2;
  }

  // getters
  meanValue() { return this.n ? this.mean : NaN; }
  variancePopulation() { return this.n ? this.M2 / this.n : NaN; }
  varianceSample() { return this.n > 1 ? this.M2 / (this.n - 1) : NaN; }
}</code></pre>

      <h3>IV. Numeric verification (digit-checked step-by-step)</h3>
      <p>
        We verify the online algorithm on the dataset:
        \(\{2,4,4,4,5,5,7,9\}\).
      </p>

      <p class="muted small">Batch calculation (control):</p>
      <p>
        Sum = \(2+4+4+4+5+5+7+9=40\). Mean = \(40/8=5.0\).
        Squared deviations: \(9,1,1,1,0,0,4,16\). Sum = 32.
        Population variance = \(32/8=4.0\). Sample variance = \(32/7\approx 4.5714285714\).
      </p>

      <p class="muted small">Now the Welford step table (each step shows n, mean, M2):</p>

      <table class="result-table" aria-label="Welford update table">
        <thead><tr><th>Step (n)</th><th>New x</th><th>mean (rounded)</th><th>M2 (rounded)</th></tr></thead>
        <tbody>
          <tr><td>1</td><td>2</td><td>2.000000</td><td>0.000000</td></tr>
          <tr><td>2</td><td>4</td><td>3.000000</td><td>2.000000</td></tr>
          <tr><td>3</td><td>4</td><td>3.333333</td><td>2.666667</td></tr>
          <tr><td>4</td><td>4</td><td>3.500000</td><td>3.000000</td></tr>
          <tr><td>5</td><td>5</td><td>3.800000</td><td>4.800000</td></tr>
          <tr><td>6</td><td>5</td><td>4.000000</td><td>6.000000</td></tr>
          <tr><td>7</td><td>7</td><td>4.428571</td><td>13.714286</td></tr>
          <tr><td>8</td><td>9</td><td>5.000000</td><td>32.000000</td></tr>
        </tbody>
      </table>

      <p>
        Final results from online method:
      </p>
      <table>
        <tr><th>Quantity</th><th>Value</th></tr>
        <tr><td>Mean (online)</td><td>5.000000</td></tr>
        <tr><td>Population variance (online)</td><td>32 / 8 = 4.000000</td></tr>
        <tr><td>Sample variance (online)</td><td>32 / 7 ‚âà 4.5714285714</td></tr>
      </table>

      <h3>V. Discussion: numerical stability, complexity, notes</h3>
      <p>
        **Complexity.** Each update costs \(O(1)\) time and the algorithm stores three scalars: count, mean and M2. Compared to batch methods (which are \(O(n)\) per update if naively recomputed), this is vastly better for streams.
      </p>
      <p>
        **Stability.** Naive two-pass or pairwise formulas that compute variance as \(\frac{1}{n}\sum x_i^2 - \bar{x}^2\) can lose precision when \(\sum x_i^2\) and \(n\bar{x}^2\) are large and nearly equal. Welford‚Äôs recurrence avoids subtracting large, similar numbers; updates use small deltas and thus reduce catastrophic cancellation and accumulated rounding error.
      </p>
      <p>
        **Mergeability.** Welford‚Äôs internal state (n, mean, M2) is mergeable: two partial aggregates can be combined to produce the same result as if processed together ‚Äî useful for distributed processing.
      </p>
      <p>
        **Caveats.** For extremely large counts (n very large) and extremely large values, floating-point overflow or gradual loss of precision can still occur; using higher-precision types (double/64-bit) or compensated algorithms may be necessary in extreme cases.
      </p>

      <h3>VI. Practical notes & submission</h3>
      <p>
        - The JavaScript class above is ready to paste into a browser console or Node.js environment.  
        - For unit testing: compare outputs vs. a batch computation on the same dataset. I demonstrated this with the example dataset above.  
        - For the optional discussion, emphasize numerical stability and O(1) update cost; mention mergeability as a practical advantage for distributed telemetry.
      </p>

      <nav class="links">
        <a href="index.html">üè† Back to blog</a>
        <a href="homework5.html">‚Üê Homework 5</a>
      </nav>
    </article>

    <footer class="muted small">
      <p>¬© 2025 Shefik Memedi ‚Äî Cybersecurity Statistics Blog ¬∑ Homework 6</p>
    </footer>
  </main>
</body>
</html>
